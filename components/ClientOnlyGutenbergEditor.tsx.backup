'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { WordPressPost, EditorContent } from '@/types';
import ImageSearchModal, { ImageResult } from './ImageSearchModal';
import CropModal from './CropModal';

interface ClientOnlyGutenbergEditorProps {
  post?: WordPressPost;
  onSave?: (post: EditorContent) => void;
  onCancel?: () => void;
}

// Helper function to convert HTML to Gutenberg blocks
const convertHtmlToBlocks = (html: string) => {
  const blocks = [];
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  
  // Process each element
  const processElement = (element: Element, index: number) => {
    const clientId = `block-${Date.now()}-${index}`;
    
    switch (element.tagName.toLowerCase()) {
      case 'p':
        return {
          clientId,
          name: 'core/paragraph',
          isValid: true,
          attributes: {
            content: element.textContent || '',
            dropCap: false
          },
          innerBlocks: []
        };
      
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return {
          clientId,
          name: 'core/heading',
          isValid: true,
          attributes: {
            content: element.textContent || '',
            level: parseInt(element.tagName.charAt(1))
          },
          innerBlocks: []
        };
      
      case 'figure':
        const img = element.querySelector('img');
        const figcaption = element.querySelector('figcaption');
        const imgSrc = img?.getAttribute('src') || '';
        const imgDataSrc = img?.getAttribute('data-src') || '';
        // Use data-src if src is a placeholder SVG
        const finalUrl = imgSrc.includes('data:image/svg+xml') ? imgDataSrc : imgSrc;
        return {
          clientId,
          name: 'core/image',
          isValid: true,
          attributes: {
            url: finalUrl,
            dataSrc: imgDataSrc,
            alt: img?.getAttribute('alt') || '',
            caption: figcaption?.textContent || '',
            clientId: clientId
          },
          innerBlocks: []
        };
      
      case 'img':
        const src = element.getAttribute('src') || '';
        const dataSrc = element.getAttribute('data-src') || '';
        const finalImgUrl = src.includes('data:image/svg+xml') ? dataSrc : src;
        return {
          clientId,
          name: 'core/image',
          isValid: true,
          attributes: {
            url: finalImgUrl,
            dataSrc: dataSrc,
            alt: element.getAttribute('alt') || '',
            clientId: clientId
          },
          innerBlocks: []
        };
      
      case 'ul':
      case 'ol':
        const listItems = Array.from(element.querySelectorAll('li'));
        return {
          clientId,
          name: 'core/list',
          isValid: true,
          attributes: {
            values: listItems.map(li => `<li>${li.textContent}</li>`).join(''),
            ordered: element.tagName.toLowerCase() === 'ol'
          },
          innerBlocks: []
        };
      
      case 'blockquote':
        return {
          clientId,
          name: 'core/quote',
          isValid: true,
          attributes: {
            value: element.textContent || '',
            citation: ''
          },
          innerBlocks: []
        };
      
      default:
        // For any other element, create a paragraph
        return {
          clientId,
          name: 'core/paragraph',
          isValid: true,
          attributes: {
            content: element.textContent || '',
            dropCap: false
          },
          innerBlocks: []
        };
    }
  };
  
  // Get all direct children of the body
  const bodyChildren = Array.from(doc.body.children);
  
  bodyChildren.forEach((element, index) => {
    const block = processElement(element, index);
    if (block) {
      blocks.push(block);
    }
  });
  
  // If no blocks were created, create a paragraph with the text content
  if (blocks.length === 0) {
    blocks.push({
      clientId: `block-${Date.now()}-0`,
      name: 'core/paragraph',
      isValid: true,
      attributes: {
        content: doc.body.textContent || '',
        dropCap: false
      },
      innerBlocks: []
    });
  }
  
  return blocks;
};

export default function ClientOnlyGutenbergEditor({ 
  post, 
  onSave, 
  onCancel 
}: ClientOnlyGutenbergEditorProps) {
  console.log('🚀 ClientOnlyGutenbergEditor rendered', { post: !!post, onSave: !!onSave, onCancel: !!onCancel });
  
  const [isClient, setIsClient] = useState(false);
  const [blocks, setBlocks] = useState<any[]>([]);
  const [title, setTitle] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [WordPressComponents, setWordPressComponents] = useState<any>(null);
  
  // Image search and crop modal states
  const [showImageSearch, setShowImageSearch] = useState(false);
  const [showCropModal, setShowCropModal] = useState(false);
  const [searchImages, setSearchImages] = useState<ImageResult[]>([]);
  const [searchLoading, setSearchLoading] = useState(false);
  const [selectedSources, setSelectedSources] = useState<string[]>(['all']);
  const [hasMoreImages, setHasMoreImages] = useState(false);
  const [searchPage, setSearchPage] = useState(1);
  const [currentImageToCrop, setCurrentImageToCrop] = useState<ImageResult | null>(null);
  const [currentBlockId, setCurrentBlockId] = useState<string | null>(null);
  const [lastSearchQuery, setLastSearchQuery] = useState<string>('');
  const [showBlockInserter, setShowBlockInserter] = useState(false);

  // Close block inserter when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (showBlockInserter && !(event.target as Element).closest('.block-editor-inserter__popover') && !(event.target as Element).closest('.block-editor-inserter__toggle')) {
        setShowBlockInserter(false);
      }
    };

    if (showBlockInserter) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [showBlockInserter]);

  // Ensure we're on the client side
  useEffect(() => {
    console.log('🌐 Setting isClient to true');
    setIsClient(true);
  }, []);

  // Load WordPress components only on client side
  useEffect(() => {
    console.log('📦 Loading WordPress components, isClient:', isClient);
    if (!isClient) return;

    const loadWordPressComponents = async () => {
      try {
        console.log('🎨 Loading WordPress CSS...');
        // Load CSS first
        console.log('✅ WordPress CSS loaded');
        
        console.log('📚 Loading WordPress components...');
        const [
          { BlockEditorProvider, BlockList, WritingFlow, ObserveTyping, BlockTools, BlockInspector },
          { Popover, SlotFillProvider, Button },
          { parse, serialize, rawHandler, registerBlockType }
        ] = await Promise.all([
          import('@wordpress/block-editor') as any,
          import('@wordpress/components') as any,
          import('@wordpress/blocks') as any
        ]);

        console.log('✅ WordPress components loaded successfully');
        // Register core blocks with proper edit/save functions
        console.log('🔧 Registering core blocks...');
        
        // Editable block edit component
        const BlockEdit = ({ attributes, setAttributes, blockName, clientId }: any) => {
          const { content, level, url, alt, caption, values, ordered, value, citation } = attributes;
          // Use the block's clientId if attributes.clientId is not available
          const blockClientId = attributes.clientId || clientId || `block-${Date.now()}-${Math.random()}`;
          const textareaRef = React.useRef(null);
          
          // Auto-resize function - Handles text wrapping properly
          const autoResize = (textarea: any) => {
            if (textarea) {
              const minHeight = blockName === 'core/paragraph' ? 32 : 28;
              
              // Store current scroll position
              const scrollTop = textarea.scrollTop;
              
              // Reset height to auto to get accurate scrollHeight
                textarea.style.height = 'auto';
              
              // Force a reflow to ensure accurate measurements
              textarea.offsetHeight;
              
              // Get the scroll height (this accounts for text wrapping)
                const scrollHeight = textarea.scrollHeight;
              
              // Calculate line height based on font size
              const fontSize = parseInt(getComputedStyle(textarea).fontSize) || 19;
              const lineHeight = fontSize * 1.5; // 1.5 line height
              
              // For empty content, use min height
              if (textarea.value.trim() === '') {
                textarea.style.height = minHeight + 'px';
              } else {
                // Use scrollHeight but ensure it's reasonable
                // Add a small buffer (4px) to prevent cutting off text
                const calculatedHeight = Math.max(minHeight, scrollHeight + 4);
                
                // Set a reasonable maximum height (e.g., 10 lines)
                const maxHeight = lineHeight * 10;
                const finalHeight = Math.min(calculatedHeight, maxHeight);
                
                textarea.style.height = finalHeight + 'px';
              }
              
              // Restore scroll position
              textarea.scrollTop = scrollTop;
            }
          };
          
          // Set initial height on mount and when content changes
          React.useEffect(() => {
            if (textareaRef.current) {
              // Use setTimeout to ensure DOM is updated
              setTimeout(() => {
              autoResize(textareaRef.current);
              }, 0);
            }
          }, [content]);
          
          // Also trigger resize when the component mounts
          React.useEffect(() => {
            if (textareaRef.current) {
              autoResize(textareaRef.current);
            }
          }, []);
          
          // Force resize on every render to ensure accuracy
          React.useEffect(() => {
            if (textareaRef.current) {
              const timer = setTimeout(() => {
                autoResize(textareaRef.current);
              }, 10);
              return () => clearTimeout(timer);
            }
          });
          
          switch (blockName) {
            case 'core/paragraph':
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  {/* <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>Paragraph</label> */}
                  <textarea
                    ref={textareaRef}
                    value={content}
                    onChange={(e) => {
                      setAttributes({ content: e.target.value });
                      autoResize(e.target);
                    }}
                    style={{ 
                      width: '100%', 
                      minHeight: '32px',
                      height: 'auto',
                      border: 'none', 
                      borderRadius: '0', 
                      padding: '0',
                      fontFamily: 'inherit',
                      fontSize: '19px',
                      lineHeight: '1.5',
                      resize: 'none',
                      overflow: 'hidden',
                      backgroundColor: 'transparent',
                      whiteSpace: 'pre-wrap',
                      minWidth: '1px',
                      outline: 'none'
                    }}
                    placeholder="Enter paragraph text..."
                  />
                </div>
              );
            case 'core/heading':
              const HeadingTag = `h${level}`;
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  {/* <div style={{ display: 'flex', gap: '8px', marginBottom: '8px', alignItems: 'center' }}>
                    <label style={{ fontSize: '12px', color: '#666' }}>Heading Level:</label>
                    <select 
                      value={level} 
                      onChange={(e) => setAttributes({ level: parseInt(e.target.value) })}
                      style={{ padding: '4px', border: '1px solid #ddd', borderRadius: '4px' }}
                    >
                      <option value={1}>H1</option>
                      <option value={2}>H2</option>
                      <option value={3}>H3</option>
                      <option value={4}>H4</option>
                      <option value={5}>H5</option>
                      <option value={6}>H6</option>
                    </select>
                  </div> */}
                  <textarea
                    ref={textareaRef}
                    value={content}
                    onChange={(e) => {
                      setAttributes({ content: e.target.value });
                      autoResize(e.target);
                    }}
                    style={{ 
                      width: '100%', 
                      minHeight: '28px',
                      height: 'auto',
                      border: 'none', 
                      borderRadius: '0', 
                      padding: '2px 0',
                      fontFamily: 'inherit',
                      fontSize: level === 1 ? '24px' : level === 2 ? '20px' : '16px',
                      fontWeight: 'bold',
                      lineHeight: '1.2',
                      resize: 'none',
                      overflow: 'hidden',
                      backgroundColor: 'transparent',
                      whiteSpace: 'pre-wrap',
                      minWidth: '1px',
                      outline: 'none'
                    }}
                    placeholder="Enter heading text..."
                  />
                </div>
              );
            case 'core/image':
              // Handle lazy loading images - use data-src if src is a placeholder
              console.log('🖼️ Image block attributes:', attributes);
              console.log('🖼️ Block clientId:', clientId);
              console.log('🖼️ Block clientId (final):', blockClientId);
              const imageUrl = url && url.includes('data:image/svg+xml') ? 
                (attributes.dataSrc || url) : url;
              
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  {!imageUrl || imageUrl === 'uploading...' ? (
                    // Upload interface for new images
                    <div style={{ marginBottom: '8px' }}>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          onClick={() => {
                            console.log('🔍 Search Images button clicked for block:', blockClientId);
                            openImageSearch(blockClientId);
                          }}
                          style={{
                            flex: 1,
                            padding: '8px 12px',
                            fontSize: '14px',
                            border: '1px solid #007cba',
                            borderRadius: '4px',
                            backgroundColor: '#007cba',
                            color: 'white',
                            cursor: 'pointer'
                          }}
                        >
                          🔍 Search Images
                        </button>
                        <input
                          type="file"
                          accept="image/*"
                          onChange={async (e) => {
                            const file = e.target.files?.[0];
                            if (file) {
                              // Show loading state
                              setAttributes({ 
                                url: 'uploading...',
                                alt: file.name.replace(/\.[^/.]+$/, "")
                              });
                              
                              try {
                                // Use WordPress media upload if available
                                if (window.wordPressUpload) {
                                  const media = await window.wordPressUpload(file);
                                  setAttributes({ 
                                    url: media.source_url,
                                    alt: file.name.replace(/\.[^/.]+$/, "")
                                  });
                                } else {
                                  // Fallback to local upload
                                  const formData = new FormData();
                                  formData.append('image', file);
                                  
                                  const response = await fetch('/api/upload-image', {
                                    method: 'POST',
                                    body: formData,
                                  });
                                  
                                  if (response.ok) {
                                    const result = await response.json();
                                    setAttributes({ 
                                      url: result.url,
                                      alt: file.name.replace(/\.[^/.]+$/, "")
                                    });
                                  } else {
                                    console.error('Upload failed:', await response.text());
                                    setAttributes({ 
                                      url: '',
                                      alt: file.name.replace(/\.[^/.]+$/, "")
                                    });
                                  }
                                }
                              } catch (error) {
                                console.error('Upload error:', error);
                                setAttributes({ 
                                  url: '',
                                  alt: file.name.replace(/\.[^/.]+$/, "")
                                });
                              }
                            }
                          }}
                          style={{ 
                            flex: 1,
                            padding: '8px', 
                            border: '1px solid #ddd', 
                            borderRadius: '4px',
                            fontSize: '14px',
                            backgroundColor: 'white'
                          }}
                        />
                      </div>
                    </div>
                  ) : (
                    // Image management interface for existing images
                    <div style={{ marginBottom: '8px' }}>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px', flexWrap: 'wrap' }}>
                        <button
                          onClick={() => {
                            console.log('🔍 Search button clicked for existing image block:', blockClientId);
                            openImageSearch(blockClientId);
                          }}
                          style={{
                            padding: '4px 8px',
                            fontSize: '12px',
                            border: '1px solid #007cba',
                            borderRadius: '4px',
                            backgroundColor: '#007cba',
                            color: 'white',
                            cursor: 'pointer'
                          }}
                        >
                          🔍 Search
                        </button>
                        <button
                          onClick={() => {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = 'image/*';
                            input.onchange = async (e) => {
                              const file = (e.target as HTMLInputElement).files?.[0];
                              if (file) {
                                setAttributes({ 
                                  url: 'uploading...',
                                  alt: file.name.replace(/\.[^/.]+$/, "")
                                });
                                
                                try {
                                  if (window.wordPressUpload) {
                                    const media = await window.wordPressUpload(file);
                                    setAttributes({ 
                                      url: media.source_url,
                                      alt: file.name.replace(/\.[^/.]+$/, "")
                                    });
                                  } else {
                                    const formData = new FormData();
                                    formData.append('image', file);
                                    
                                    const response = await fetch('/api/upload-image', {
                                      method: 'POST',
                                      body: formData,
                                    });
                                    
                                    if (response.ok) {
                                      const result = await response.json();
                                      setAttributes({ 
                                        url: result.url,
                                        alt: file.name.replace(/\.[^/.]+$/, "")
                                      });
                                    }
                                  }
                                } catch (error) {
                                  console.error('Upload error:', error);
                                }
                              }
                            };
                            input.click();
                          }}
                          style={{
                            padding: '4px 8px',
                            fontSize: '12px',
                            border: '1px solid #ddd',
                            borderRadius: '4px',
                            backgroundColor: 'white',
                            cursor: 'pointer'
                          }}
                        >
                          Replace Image
                        </button>
                        <button
                          onClick={() => setAttributes({ url: '', alt: '', caption: '' })}
                          style={{
                            padding: '4px 8px',
                            fontSize: '12px',
                            border: '1px solid #ddd',
                            borderRadius: '4px',
                            backgroundColor: 'white',
                            cursor: 'pointer'
                          }}
                        >
                          Remove Image
                        </button>
                      </div>
                    </div>
                  )}
                  
                  {/* <div style={{ marginBottom: '8px' }}>
                    <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>Alt Text:</label>
                    <input
                      type="text"
                      value={alt}
                      onChange={(e) => setAttributes({ alt: e.target.value })}
                      style={{ 
                        width: '100%', 
                        padding: '8px', 
                        border: '1px solid #ddd', 
                        borderRadius: '4px',
                        fontSize: '14px'
                      }}
                      placeholder="Enter alt text..."
                    />
                  </div> */}
                  {imageUrl && (
                    <figure style={{ margin: '8px 0', textAlign: 'center' }}>
                      <img 
                        src={imageUrl} 
                        alt={alt} 
                        style={{ 
                          maxWidth: '100%', 
                          height: 'auto',
                          display: 'block',
                          margin: '0 auto',
                          border: 'none',
                          borderRadius: '0'
                        }}
                        onError={(e: any) => {
                          // Fallback to data-src if main src fails
                          if (attributes.dataSrc && e.target.src !== attributes.dataSrc) {
                            e.target.src = attributes.dataSrc;
                          }
                        }}
                      />
                      <input
                        type="text"
                        value={caption}
                        onChange={(e) => setAttributes({ caption: e.target.value })}
                        style={{ 
                          width: '100%', 
                          padding: '0', 
                          border: 'none', 
                          borderRadius: '0',
                          fontSize: '14px',
                          color: '#666',
                          marginTop: '8px',
                          textAlign: 'center',
                          fontStyle: 'italic',
                          backgroundColor: 'transparent',
                          whiteSpace: 'pre-wrap',
                          minWidth: '1px',
                          outline: 'none'
                        }}
                        placeholder="Enter caption..."
                      />
                    </figure>
                  )}
                </div>
              );
            case 'core/list':
              const listItems = values ? values.split('</li>').filter((item: string) => item.trim()) : [];
              
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>List Type:</label>
                    <select 
                      value={ordered ? 'ol' : 'ul'} 
                      onChange={(e) => setAttributes({ ordered: e.target.value === 'ol' })}
                      style={{ padding: '4px', border: '1px solid #ddd', borderRadius: '4px' }}
                    >
                      <option value="ul">Unordered List</option>
                      <option value="ol">Ordered List</option>
                    </select>
                  </div>
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>List Items (one per line):</label>
                    <textarea
                      value={listItems.map((item: any) => item.replace('<li>', '').trim()).join('\n')}
                      onChange={(e) => {
                        const items = e.target.value.split('\n').filter((item: any) => item.trim());
                        setAttributes({ values: items.map((item: any) => `<li>${item.trim()}</li>`).join('') });
                      }}
                      style={{ 
                        width: '100%', 
                        minHeight: '80px', 
                        border: '1px solid #ddd', 
                        borderRadius: '4px', 
                        padding: '8px',
                        fontFamily: 'inherit',
                        fontSize: '14px',
                        resize: 'vertical'
                      }}
                      placeholder="Enter list items, one per line..."
                    />
                  </div>
                  {values && (
                    <div style={{ margin: '8px 0', padding: '8px', border: '1px solid #ddd', borderRadius: '4px', backgroundColor: 'white' }}>
                      {ordered ? (
                        <ol>
                          {listItems.map((item: string, index: number) => 
                            item.trim() ? <li key={index} dangerouslySetInnerHTML={{ __html: item.replace('<li>', '') }} /> : null
                          )}
                        </ol>
                      ) : (
                        <ul>
                          {listItems.map((item: string, index: number) => 
                            item.trim() ? <li key={index} dangerouslySetInnerHTML={{ __html: item.replace('<li>', '') }} /> : null
                          )}
                        </ul>
                      )}
                    </div>
                  )}
                </div>
              );
            case 'core/quote':
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>Quote Text:</label>
                    <textarea
                      value={value}
                      onChange={(e) => setAttributes({ value: e.target.value })}
                      style={{ 
                        width: '100%', 
                        minHeight: '60px', 
                        border: '1px solid #ddd', 
                        borderRadius: '4px', 
                        padding: '8px',
                        fontFamily: 'inherit',
                        fontSize: '14px',
                        resize: 'vertical'
                      }}
                      placeholder="Enter quote text..."
                    />
                  </div>
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>Citation:</label>
                    <input
                      type="text"
                      value={citation}
                      onChange={(e) => setAttributes({ citation: e.target.value })}
                      style={{ 
                        width: '100%', 
                        padding: '8px', 
                        border: '1px solid #ddd', 
                        borderRadius: '4px',
                        fontSize: '14px'
                      }}
                      placeholder="Enter citation..."
                    />
                  </div>
                  {value && (
                    <blockquote style={{ margin: '8px 0', padding: '8px', borderLeft: '4px solid #ddd', fontStyle: 'italic', backgroundColor: 'white' }}>
                      {value}
                      {citation && <cite style={{ display: 'block', marginTop: '8px', fontSize: '0.9em' }}>— {citation}</cite>}
                    </blockquote>
                  )}
                </div>
              );
            default:
              return (
                <div style={{ margin: '1em 0', padding: '0', border: 'none', backgroundColor: 'transparent' }}>
                  <label style={{ display: 'block', fontSize: '12px', color: '#666', marginBottom: '4px' }}>Content</label>
                  <textarea
                    value={content}
                    onChange={(e) => setAttributes({ content: e.target.value })}
                    style={{ 
                      width: '100%', 
                      minHeight: '60px', 
                      border: '1px solid #ddd', 
                      borderRadius: '4px', 
                      padding: '8px',
                      fontFamily: 'inherit',
                      fontSize: '14px',
                      resize: 'vertical'
                    }}
                    placeholder="Enter content..."
                  />
                </div>
              );
          }
        };
        
        registerBlockType('core/paragraph', {
          title: 'Paragraph',
          category: 'text',
          attributes: {
            content: { type: 'string' },
            dropCap: { type: 'boolean', default: false }
          },
          edit: (props: any) => <BlockEdit {...props} blockName="core/paragraph" />,
          save: () => null
        });
        
        registerBlockType('core/heading', {
          title: 'Heading',
          category: 'text',
          attributes: {
            content: { type: 'string' },
            level: { type: 'number', default: 2 }
          },
          edit: (props: any) => <BlockEdit {...props} blockName="core/heading" />,
          save: () => null
        });
        
        registerBlockType('core/image', {
          title: 'Image',
          category: 'media',
          attributes: {
            url: { type: 'string' },
            alt: { type: 'string' },
            caption: { type: 'string' },
            clientId: { type: 'string' }
          },
          edit: (props: any) => <BlockEdit {...props} blockName="core/image" />,
          save: () => null
        });
        
        registerBlockType('core/list', {
          title: 'List',
          category: 'text',
          attributes: {
            values: { type: 'string' },
            ordered: { type: 'boolean', default: false }
          },
          edit: (props: any) => <BlockEdit {...props} blockName="core/list" />,
          save: () => null
        });
        
        registerBlockType('core/quote', {
          title: 'Quote',
          category: 'text',
          attributes: {
            value: { type: 'string' },
            citation: { type: 'string' }
          },
          edit: (props: any) => <BlockEdit {...props} blockName="core/quote" />,
          save: () => null
        });

        console.log('✅ Core blocks registered');
        
        setWordPressComponents({
          BlockEditorProvider,
          BlockList,
          WritingFlow,
          ObserveTyping,
          BlockTools,
          BlockInspector,
          Popover,
          SlotFillProvider,
          Button,
          parse,
          serialize,
          rawHandler
        });
      } catch (error) {
        console.error('❌ Error loading WordPress components:', error);
      }
    };

    loadWordPressComponents();
  }, [isClient]);

  // Initialize editor with post data
  useEffect(() => {
    console.log('🔄 Initializing editor', { WordPressComponents: !!WordPressComponents, post: !!post });
    if (!WordPressComponents || !post) {
      console.log('⏳ Waiting for WordPress components or post data');
      setIsLoading(false);
      return;
    }

    const initializeEditor = async () => {
      console.log('📝 Initializing editor with post data');
      setTitle(post.title?.rendered || '');
      
      if (post.content?.rendered) {
        try {
          console.log('🔍 Parsing post content...');
          console.log('📄 Raw post content:', post.content.rendered);
          console.log('📄 Post content length:', post.content.rendered.length);
          const parsedBlocks = WordPressComponents.parse(post.content.rendered);
          console.log('✅ Parsed blocks:', parsedBlocks.length);
          console.log('📋 Parsed blocks details:', parsedBlocks);
          
          if (parsedBlocks.length === 0) {
            console.log('⚠️ No blocks parsed - content might be in HTML format, manually converting HTML to blocks');
            // Manually convert HTML to blocks
            try {
              const htmlContent = post.content.rendered;
              const blocks = convertHtmlToBlocks(htmlContent);
              console.log('✅ Manually converted blocks:', blocks.length);
              console.log('📋 Converted blocks details:', blocks);
              setBlocks(blocks);
            } catch (conversionError) {
              console.error('❌ Error converting HTML to blocks:', conversionError);
              // Fallback: create a paragraph block with the content
              const paragraphBlock = {
                clientId: 'paragraph-' + Date.now(),
                name: 'core/paragraph',
                isValid: true,
                attributes: {
                  content: post.content.rendered.replace(/<[^>]*>/g, ''), // Strip HTML tags
                  dropCap: false
                },
                innerBlocks: []
              };
              setBlocks([paragraphBlock]);
            }
          } else {
            setBlocks(parsedBlocks);
          }
        } catch (error) {
          console.error('❌ Error parsing blocks:', error);
          // Create a paragraph block with the content
          const paragraphBlock = {
            clientId: 'paragraph-' + Date.now(),
            name: 'core/paragraph',
            isValid: true,
            attributes: {
              content: post.content.rendered.replace(/<[^>]*>/g, ''), // Strip HTML tags
              dropCap: false
            },
            innerBlocks: []
          };
          setBlocks([paragraphBlock]);
        }
      } else {
        console.log('📄 No content to parse');
        console.log('📄 Post object:', post);
        setBlocks([]);
      }
      setIsLoading(false);
    };

    initializeEditor();
  }, [WordPressComponents, post]);

  // Handle block changes
  const handleBlocksChange = useCallback((newBlocks: any) => {
    setBlocks(newBlocks);
  }, []);

  // Custom serialization function to create proper WordPress block markup
  const serializeBlocksToWordPress = (blocks: any[]) => {
    return blocks.map(block => {
      const { name, attributes } = block;
      
      switch (name) {
        case 'core/paragraph':
          return `<!-- wp:paragraph -->\n<p>${attributes.content || ''}</p>\n<!-- /wp:paragraph -->`;
        
        case 'core/heading':
          const level = attributes.level || 2;
          return `<!-- wp:heading -->\n<h${level}>${attributes.content || ''}</h${level}>\n<!-- /wp:heading -->`;
        
        case 'core/image':
          const { url, alt, caption } = attributes;
          const captionHtml = caption ? `<figcaption>${caption}</figcaption>` : '';
          return `<!-- wp:image -->\n<figure class="wp-block-image">\n<img src="${url || ''}" alt="${alt || ''}"/>\n${captionHtml}\n</figure>\n<!-- /wp:image -->`;
        
        case 'core/list':
          const { values, ordered } = attributes;
          const listTag = ordered ? 'ol' : 'ul';
          const listItems = values ? values.map((item: any) => `<li>${item}</li>`).join('\n') : '';
          return `<!-- wp:list -->\n<${listTag}>\n${listItems}\n</${listTag}>\n<!-- /wp:list -->`;
        
        case 'core/quote':
          const { value, citation } = attributes;
          return `<!-- wp:quote -->\n<blockquote>\n<p>${value || ''}</p>\n<cite>${citation || ''}</cite>\n</blockquote>\n<!-- /wp:quote -->`;
        
        default:
          return `<!-- wp:paragraph -->\n<p>${attributes.content || ''}</p>\n<!-- /wp:paragraph -->`;
      }
    }).join('\n\n');
  };

  // Handle save
  const handleSave = useCallback(async () => {
    if (onSave) {
      try {
        const serializedContent = serializeBlocksToWordPress(blocks);
        console.log('📝 Serialized content:', serializedContent);
        console.log('📝 Title being saved:', title);

        const updatedPost: EditorContent = {
          title: title, // Pass title as string for WordPress REST API
          content: serializedContent, // Pass content as string for WordPress REST API
          excerpt: typeof post?.excerpt === 'string' ? post.excerpt : post?.excerpt?.rendered || '',
          status: 'draft' as 'publish' | 'draft' | 'private' | 'pending',
          featured_media: post?.featured_media || null,
          categories: post?.categories || [],
          tags: post?.tags || []
        };
        console.log('📝 Full post object being saved:', updatedPost);
        onSave(updatedPost);
      } catch (error) {
        console.error('Error serializing blocks:', error);
      }
    }
  }, [blocks, title, post, onSave]);

  // Image search functions
  const handleImageSearch = async (query: string, loadMore = false) => {
    if (!query.trim() && !loadMore) return;
    
    setSearchLoading(true);
    try {
      const searchQuery = loadMore ? lastSearchQuery : query;
      if (!loadMore) {
        setLastSearchQuery(query);
      }
      
      const page = loadMore ? searchPage + 1 : 1;
      const response = await fetch(`/api/search-images?query=${encodeURIComponent(searchQuery)}&sources=${selectedSources.join(',')}&page=${page}&perPage=20`);
      const data = await response.json();
      
      if (loadMore) {
        setSearchImages(prev => [...prev, ...data.images]);
        setSearchPage(page);
      } else {
        setSearchImages(data.images);
        setSearchPage(1);
      }
      setHasMoreImages(data.hasMore);
    } catch (error) {
      console.error('Image search error:', error);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleImageSelect = (image: ImageResult) => {
    setCurrentImageToCrop(image);
    setShowImageSearch(false);
    setShowCropModal(true);
  };

  const handleCropConfirm = async (croppedImageUrl: string) => {
    if (!currentImageToCrop || !currentBlockId) return;
    
    try {
      // Upload the cropped image
      const response = await fetch(croppedImageUrl);
      const blob = await response.blob();
      const file = new File([blob], 'cropped-image.jpg', { type: 'image/jpeg' });
      
      let finalUrl = croppedImageUrl;
      
      // Try to upload to WordPress if available
      if (window.wordPressUpload) {
        try {
          const media = await window.wordPressUpload(file);
          finalUrl = media.source_url;
        } catch (error) {
          console.error('WordPress upload failed, using local URL:', error);
        }
      } else {
        // Fallback to local upload
        try {
          const formData = new FormData();
          formData.append('image', file);
          const uploadResponse = await fetch('/api/upload-image', {
            method: 'POST',
            body: formData,
          });
          if (uploadResponse.ok) {
            const result = await uploadResponse.json();
            finalUrl = result.url;
          }
        } catch (error) {
          console.error('Local upload failed:', error);
        }
      }
      
      // Create caption with attribution for Unsplash and Pexels images
      let imageCaption = '';
      let imageAlt = currentImageToCrop.caption; // Use original caption for alt text
      
      if (currentImageToCrop.attribution && (currentImageToCrop.source === 'unsplash' || currentImageToCrop.source === 'pexels')) {
        imageCaption = currentImageToCrop.attribution; // Only show photographer attribution in caption
      }

      // Update the block with the cropped image
      setBlocks(prevBlocks => 
        prevBlocks.map(block => 
          block.clientId === currentBlockId 
            ? { ...block, attributes: { ...block.attributes, url: finalUrl, alt: imageAlt, caption: imageCaption } }
            : block
        )
      );
      
      setShowCropModal(false);
      setCurrentImageToCrop(null);
      setCurrentBlockId(null);
    } catch (error) {
      console.error('Error processing cropped image:', error);
    }
  };

  const handleSourceToggle = (source: string) => {
    setSelectedSources(prev => 
      prev.includes(source) 
        ? prev.filter(s => s !== source)
        : [...prev, source]
    );
  };

  const openImageSearch = (blockId: string) => {
    console.log('🔍 Opening image search for block:', blockId);
    setCurrentBlockId(blockId);
    setShowImageSearch(true);
    setSearchImages([]);
    console.log('🔍 Image search modal should now be visible');
  };

  // Block editor settings
  const blockEditorSettings = {
    hasFixedToolbar: true,
    focusMode: false,
    hasReducedUI: false,
    __experimentalFeatures: {
      typography: {
        fontSize: true,
        fontFamily: true,
        fontStyle: true,
        fontWeight: true,
        letterSpacing: true,
        lineHeight: true,
        textDecoration: true,
        textTransform: true,
      },
      color: {
        background: true,
        custom: true,
        customDuotone: true,
        customGradient: true,
        defaultDuotone: true,
        defaultGradient: true,
        defaultPalette: true,
        duotone: true,
        gradients: true,
        link: true,
        palette: true,
        text: true,
      },
      spacing: {
        blockGap: true,
        margin: true,
        padding: true,
        units: ['px', 'em', 'rem', 'vh', 'vw', '%'],
      },
    },
  };

  // Show loading while checking client side or loading WordPress components
  console.log('🎯 Render check', { isClient, isLoading, WordPressComponents: !!WordPressComponents });
  
  if (!isClient || isLoading || !WordPressComponents) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
        <span className="ml-3 text-gray-600">
          Loading WordPress Editor... 
          {!isClient && ' (Client)'}
          {isLoading && ' (Loading)'}
          {!WordPressComponents && ' (Components)'}
        </span>
      </div>
    );
  }

  const {
    BlockEditorProvider,
    BlockList,
    WritingFlow,
    ObserveTyping,
    BlockTools,
    BlockInspector,
    SlotFillProvider,
    Button
  } = WordPressComponents;

  console.log('🎨 Rendering Gutenberg editor', { 
    title, 
    blocksCount: blocks.length, 
    blocks: blocks 
  });
  
  // Debug: Log first few blocks to see their structure
  if (blocks.length > 0) {
    console.log('🔍 First 3 blocks structure:', blocks.slice(0, 3));
  }

  return (
    <div className="official-gutenberg-editor">
      {/* WordPress-style Editor Container */}
      <div className="editor-styles-wrapper block-editor-writing-flow" style={{ minHeight: '100%', width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        
        {/* Header with Title and Buttons */}
        <div className="editor-visual-editor__post-title-wrapper edit-post-visual-editor__post-title-wrapper has-global-padding" style={{ marginTop: '0.5rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%', maxWidth: '650px' }}>
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="Add title"
            className="wp-block wp-block-post-title block-editor-block-list__block editor-post-title editor-post-title__input rich-text"
            aria-label="Add title"
            style={{ 
              fontSize: '2.5rem',
              fontWeight: 'bold',
              lineHeight: '1.2',
              margin: '0',
              padding: '0',
              border: 'none',
              outline: 'none',
              backgroundColor: 'transparent',
              textAlign: 'left',
              flex: '1',
              width: '100%'
            }}
          />
          
          <div className="flex items-center space-x-3">
            <Button 
              variant="tertiary" 
              onClick={onCancel}
            >
              Cancel
            </Button>
            <Button 
              variant="primary" 
              onClick={handleSave}
            >
              Save
            </Button>
          </div>
        </div>

        {/* Block Editor */}
        <div className="block-editor-container" style={{ width: '100%', maxWidth: '650px', margin: '0 auto' }}>
        <SlotFillProvider>
          <BlockEditorProvider
            value={blocks}
            onInput={handleBlocksChange}
            onChange={handleBlocksChange}
            settings={blockEditorSettings}
          >
            <div className="is-root-container is-desktop-preview is-layout-constrained wp-block-post-content-is-layout-constrained has-global-padding wp-block-post-content has-global-padding block-editor-block-list__layout" style={{ textAlign: 'center', maxWidth: '650px', margin: '0 auto' }}>
              <BlockTools>
                <WritingFlow>
                  <ObserveTyping>
                    <BlockList />
                  </ObserveTyping>
                </WritingFlow>
              </BlockTools>
              
              {/* Block Inserter Container */}
              <div style={{ position: 'relative', margin: '2rem 0', display: 'flex', justifyContent: 'center' }}>
                {/* Block Inserter Toggle Button */}
                <button
                  type="button"
                  className="components-button block-editor-inserter__toggle is-next-40px-default-size has-icon"
                  aria-label="Add block"
                  onClick={() => setShowBlockInserter(!showBlockInserter)}
                    style={{ 
                    background: '#007cba',
                    color: 'white',
                      border: 'none',
                    borderRadius: '4px',
                    padding: '8px 12px',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                  }}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" focusable="false">
                    <path d="M11 12.5V17.5H12.5V12.5H17.5V11H12.5V6H11V11H6V12.5H11Z"></path>
                  </svg>
                  Add Block
                </button>

                {/* WordPress Gutenberg Block Inserter - Perfect Match */}
                {showBlockInserter && (
                  <div className="components-popover components-dropdown__content block-editor-inserter__popover is-quick is-positioned" 
                      style={{ position: 'absolute', top: '100%', left: '50%', transform: 'translateX(-50%) translateY(8px)', opacity: 1, zIndex: 100000, margin: 0, width: '400px', maxWidth: '90vw' }}>
                <div className="components-popover__content" style={{ maxHeight: '473px', overflow: 'auto' }}>
                  <div className="block-editor-inserter__quick-inserter has-search has-expand">
                    
                    {/* Search Control */}
                    <div className="components-base-control components-input-control components-search-control block-editor-inserter__search">
                      <div className="components-base-control__field">
                        <div className="components-flex components-input-base">
                          <label className="components-visually-hidden" htmlFor="components-search-control-block-inserter">
                            Search
                          </label>
                          <div className="components-input-control__container">
                            <input 
                              autoComplete="off" 
                              placeholder="Search" 
                              className="components-input-control__input" 
                              id="components-search-control-block-inserter" 
                              type="search" 
                              value=""
                              readOnly
                            />
                            <span className="components-input-control__suffix">
                              <div>
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" focusable="false">
                                  <path d="M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path>
                                </svg>
                              </div>
                            </span>
                            <div aria-hidden="true" className="components-input-control__backdrop"></div>
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* Block Types List */}
                    <div className="block-editor-inserter__quick-inserter-results">
                      <div className="block-editor-inserter__panel-header">
                        <h2 className="block-editor-inserter__panel-title">
                          <div className="components-visually-hidden">Blocks</div>
                        </h2>
                      </div>
                      <div className="block-editor-inserter__panel-content">
                        <div role="listbox" aria-orientation="horizontal" className="block-editor-block-types-list" aria-label="Blocks">
                          
                          {/* Paragraph Block */}
                          <div role="presentation">
                            <div className="block-editor-block-types-list__list-item" draggable="false">
                              <button 
                                type="button" 
                                role="option" 
                                tabIndex={0} 
                                className="components-button block-editor-block-types-list__item editor-block-list-item-paragraph is-next-40px-default-size"
                    onClick={() => {
                      const newBlock = {
                                    name: 'core/paragraph',
                                    attributes: { content: 'New paragraph block' },
                        clientId: `block-${Date.now()}`
                      };
                      setBlocks([...blocks, newBlock]);
                                  setShowBlockInserter(false);
                                }}
                              >
                                <span className="block-editor-block-types-list__item-icon">
                                  <span className="block-editor-block-icon has-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" focusable="false">
                                      <path d="m9.99609 14v-.2251l.00391.0001v6.225h1.5v-14.5h2.5v14.5h1.5v-14.5h3v-1.5h-8.50391c-2.76142 0-5 2.23858-5 5 0 2.7614 2.23858 5 5 5z"></path>
                                    </svg>
                                  </span>
                                </span>
                                <span className="block-editor-block-types-list__item-title">
                                  <span className="components-truncate">Paragraph</span>
                                </span>
                              </button>
                            </div>
                          </div>

                          {/* Image Block */}
                          <div role="presentation">
                            <div className="block-editor-block-types-list__list-item" draggable="false">
                              <button 
                                type="button" 
                                role="option" 
                                className="components-button block-editor-block-types-list__item editor-block-list-item-image is-next-40px-default-size"
                                tabIndex={-1}
                    onClick={() => {
                      const newBlock = {
                        name: 'core/image',
                        attributes: { 
                          url: '',
                          alt: '',
                          caption: '',
                          clientId: `block-${Date.now()}`
                        },
                        clientId: `block-${Date.now()}`
                      };
                      setBlocks([...blocks, newBlock]);
                                  setShowBlockInserter(false);
                                }}
                              >
                                <span className="block-editor-block-types-list__item-icon">
                                  <span className="block-editor-block-icon has-colors">
                                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true" focusable="false">
                                      <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5 4.5h14c.3 0 .5.2.5.5v8.4l-3-2.9c-.3-.3-.8-.3-1 0L11.9 14 9 12c-.3-.2-.6-.2-.8 0l-3.6 2.6V5c-.1-.3.1-.5.4-.5zm14 15H5c-.3 0-.5-.2-.5-.5v-2.4l4.1-3 3 1.9c.3.2.7.2.9-.1L16 12l3.5 3.4V19c0 .3-.2.5-.5.5z"></path>
                                    </svg>
                                  </span>
                                </span>
                                <span className="block-editor-block-types-list__item-title">
                                  <span className="components-truncate">Image</span>
                                </span>
                              </button>
                            </div>
                          </div>

                          {/* Heading Block */}
                          <div role="presentation">
                            <div className="block-editor-block-types-list__list-item" draggable="false">
                              <button 
                                type="button" 
                                role="option" 
                                className="components-button block-editor-block-types-list__item editor-block-list-item-heading is-next-40px-default-size"
                                tabIndex={-1}
                                onClick={() => {
                                  const newBlock = {
                                    name: 'core/heading',
                                    attributes: { content: 'New heading', level: 2 },
                                    clientId: `block-${Date.now()}`
                                  };
                                  setBlocks([...blocks, newBlock]);
                                }}
                              >
                                <span className="block-editor-block-types-list__item-icon">
                                  <span className="block-editor-block-icon has-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" focusable="false">
                                      <path d="M6 5V18.5911L12 13.8473L18 18.5911V5H6Z"></path>
                                    </svg>
                                  </span>
                                </span>
                                <span className="block-editor-block-types-list__item-title">
                                  <span className="components-truncate">Heading</span>
                                </span>
                              </button>
                            </div>
                          </div>

                          {/* List Block */}
                          <div role="presentation">
                            <div className="block-editor-block-types-list__list-item" draggable="false">
                              <button 
                                type="button" 
                                role="option" 
                                className="components-button block-editor-block-types-list__item editor-block-list-item-list is-next-40px-default-size"
                                tabIndex={-1}
                    onClick={() => {
                      const newBlock = {
                        name: 'core/list',
                        attributes: { 
                          values: '<li>List item 1</li><li>List item 2</li>',
                          ordered: false
                        },
                        clientId: `block-${Date.now()}`
                      };
                      setBlocks([...blocks, newBlock]);
                    }}
                              >
                                <span className="block-editor-block-types-list__item-icon">
                                  <span className="block-editor-block-icon has-colors">
                                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true" focusable="false">
                                      <path d="M9 5h1v1H9V5zm-2 0v1H6V5h1zm4 0v1h-1V5h1zm2 0v1h-1V5h1zm-6 3h1v1H7V8zm2 0v1H8V8h1zm2 0v1h-1V8h1zm2 0v1h-1V8h1zm-6 3h1v1H7v-1zm2 0v1H8v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1z"></path>
                                    </svg>
                                  </span>
                                </span>
                                <span className="block-editor-block-types-list__item-title">
                                  <span className="components-truncate">List</span>
                                </span>
                              </button>
                            </div>
                          </div>

                          {/* Quote Block */}
                          <div role="presentation">
                            <div className="block-editor-block-types-list__list-item" draggable="false">
                              <button 
                                type="button" 
                                role="option" 
                                className="components-button block-editor-block-types-list__item editor-block-list-item-quote is-next-40px-default-size"
                                tabIndex={-1}
                    onClick={() => {
                      const newBlock = {
                        name: 'core/quote',
                        attributes: { 
                          value: 'Quote text',
                          citation: 'Citation'
                        },
                        clientId: `block-${Date.now()}`
                      };
                      setBlocks([...blocks, newBlock]);
                    }}
                              >
                                <span className="block-editor-block-types-list__item-icon">
                                  <span className="block-editor-block-icon has-colors">
                                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true" focusable="false">
                                      <path d="M7.5 6.5h3v3h-3v-3zm6 0h3v3h-3v-3zM7.5 12h3v3h-3v-3zm6 0h3v3h-3v-3z"></path>
                                    </svg>
                                  </span>
                                </span>
                                <span className="block-editor-block-types-list__item-title">
                                  <span className="components-truncate">Quote</span>
                                </span>
                              </button>
                            </div>
                          </div>

                        </div>
                      </div>
                      
                      {/* Browse All Button */}
                      <button 
                        type="button" 
                        aria-label="Browse all. This will open the main inserter panel in the editor toolbar." 
                        className="components-button block-editor-inserter__quick-inserter-expand is-next-40px-default-size"
                        onClick={() => {
                          // Could open a more comprehensive block inserter here
                          console.log('Browse all blocks clicked');
                        }}
                      >
                        Browse all
                      </button>
                </div>
              </div>
            </div>
                )}
            </div> {/* Close Block Inserter Container */}
            </div> {/* Close is-root-container */}
            
            {/* Block Inspector Sidebar */}
            <div className="block-editor-sidebar">
              <BlockInspector />
            </div>
          </BlockEditorProvider>
        </SlotFillProvider>
        </div>
      </div>

      
      {/* Image Search Modal */}
      <ImageSearchModal
        isOpen={showImageSearch}
        selectedSources={selectedSources}
        onSourceToggle={handleSourceToggle}
        onSearch={handleImageSearch}
        onSelect={handleImageSelect}
        onClose={() => setShowImageSearch(false)}
        images={searchImages}
        loading={searchLoading}
        hasMore={hasMoreImages}
        loadMore={() => handleImageSearch(lastSearchQuery, true)}
      />
      
      {/* Crop Modal */}
      <CropModal
        isOpen={showCropModal}
        imageSrc={currentImageToCrop?.full || currentImageToCrop?.url || ''}
        onCancel={() => {
          setShowCropModal(false);
          setCurrentImageToCrop(null);
          setCurrentBlockId(null);
        }}
        onConfirm={handleCropConfirm}
        loading={false}
      />
    </div>
  );
}
